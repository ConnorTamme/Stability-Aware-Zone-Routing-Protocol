//
// Generated file, do not edit! Created by opp_msgtool 6.3 from ZrpControlPackets.msg.
//

#ifndef __INET__ZRP_ZRPCONTROLPACKETS_M_H
#define __INET__ZRP_ZRPCONTROLPACKETS_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0603
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif


namespace inet {
namespace zrp {

class NDP_Hello;
struct IARP_MetricData;
struct IARP_LinkDestData;
class IARP_LinkStateUpdate;
class IERP_RouteData;
class BRP_Data;

}  // namespace zrp
}  // namespace inet

// cplusplus {{
#include "Zrp.h"
// }}

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/common/packet/chunk/Chunk_m.h" // import inet.common.packet.chunk.Chunk

#include "inet/common/packet/Packet_m.h" // import inet.common.packet.Packet

#include "inet/networklayer/common/L3Address_m.h" // import inet.networklayer.common.L3Address


namespace inet {
namespace zrp {

/**
 * Class generated from <tt>ZrpControlPackets.msg:30</tt> by opp_msgtool.
 * <pre>
 * //The Neighbor Discovery Protocol is not included in the RFC so this is used to obtain neighboring nodes
 * class NDP_Hello extends FieldsChunk
 * {
 *     L3Address nodeAddress;
 *     uint16_t seqNum;
 * }
 * 
 * 
 * //
 * // IARP Link State Update Packet
 * //
 * //                       1                   2                   3
 * //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * //   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * //   |                       Link Source Address                     |
 * //   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * //   |       Link State Seq Num      |  Zone Radius  |      TTL      |
 * //   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * //   |          RESERVED             |   RESERVED    | Link Dest Cnt |
 * //   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * //   |                    Link Destination 1 Address                 |
 * //   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * //   |            Link Destination 1 Subnet Mask  (Optional)         |
 * //   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ --+--
 * //   |   RESERVED    |  Metric Type  |          Metric Value         |   |
 * //   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  Link
 * //   |   RESERVED    |  Metric Type  |          Metric Value         | Metrics
 * //   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
 * //   |   RESERVED    |  Metric Type  |          Metric Value         |   |
 * //   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ --+--
 * //                                 |  | 
 * //                                 |  | 
 * //                                \|  |/
 * //                                 \  /                                  
 * //                                  \/
 * //   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * //   |                    Link Destination n Address                 |
 * //   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * //   |            Link Destination n Subnet Mask  (Optional)         |
 * //   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ --+--
 * //   |   RESERVED    |  Metric Type  |          Metric Value         |   |
 * //   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  Link
 * //   |   RESERVED    |  Metric Type  |          Metric Value         | Metrics
 * //   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+   |
 * //   |   RESERVED    |  Metric Type  |          Metric Value         |   |
 * //   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ --+--
 * //
 * 
 * 
 * //All reserved fields are set to 0
 * </pre>
 */
class NDP_Hello : public ::inet::FieldsChunk
{
  protected:
    ::inet::L3Address nodeAddress;
    uint16_t seqNum = 0;

  private:
    void copy(const NDP_Hello& other);

  protected:
    bool operator==(const NDP_Hello&) = delete;

  public:
    NDP_Hello();
    NDP_Hello(const NDP_Hello& other);
    virtual ~NDP_Hello();
    NDP_Hello& operator=(const NDP_Hello& other);
    virtual NDP_Hello *dup() const override {return new NDP_Hello(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const ::inet::L3Address& getNodeAddress() const;
    virtual ::inet::L3Address& getNodeAddressForUpdate() { handleChange();return const_cast<::inet::L3Address&>(const_cast<NDP_Hello*>(this)->getNodeAddress());}
    virtual void setNodeAddress(const ::inet::L3Address& nodeAddress);

    virtual uint16_t getSeqNum() const;
    virtual void setSeqNum(uint16_t seqNum);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NDP_Hello& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NDP_Hello& obj) {obj.parsimUnpack(b);}

/**
 * Struct generated from ZrpControlPackets.msg:79 by opp_msgtool.
 */
struct IARP_MetricData
{
    IARP_MetricData();
    uint8_t reserved = 0;
    uint8_t metricType = 0;
    uint16_t metricValue = 0;
};

// helpers for local use
void __doPacking(omnetpp::cCommBuffer *b, const IARP_MetricData& a);
void __doUnpacking(omnetpp::cCommBuffer *b, IARP_MetricData& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const IARP_MetricData& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, IARP_MetricData& obj) { __doUnpacking(b, obj); }

/**
 * Struct generated from ZrpControlPackets.msg:87 by opp_msgtool.
 */
struct IARP_LinkDestData
{
    IARP_LinkDestData();
    ::inet::L3Address addr;
    IARP_MetricData metrics[IARP_METRIC_COUNT];
};

// helpers for local use
void __doPacking(omnetpp::cCommBuffer *b, const IARP_LinkDestData& a);
void __doUnpacking(omnetpp::cCommBuffer *b, IARP_LinkDestData& a);

inline void doParsimPacking(omnetpp::cCommBuffer *b, const IARP_LinkDestData& obj) { __doPacking(b, obj); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, IARP_LinkDestData& obj) { __doUnpacking(b, obj); }

/**
 * Class generated from <tt>ZrpControlPackets.msg:96</tt> by opp_msgtool.
 * <pre>
 * class IARP_LinkStateUpdate extends FieldsChunk
 * {
 *     L3Address sourceAddr;
 *     uint16_t seqNum;
 *     uint8_t radius;
 *     uint8_t TTL;
 *     uint16_t reserved1 = 0;
 *     uint8_t reserved2 = 0;
 *     uint8_t linkDestCount; //The number of neighbors the source has
 *     IARP_LinkDestData linkDestData[];
 * }
 * 
 * //IERP Packet
 * //
 * //                        1                   2                   3
 * //    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * //    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * //    |     Type      |     Length    |    Node Ptr   |    RESERVED   |
 * //    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * //    |           Query ID            |        R E S E R V E D        |
 * //    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
 * //    |                  Query/Route Source Address                   |  
 * //    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -+-
 * //    |                 Intermediate Node (1) Address                 |  |
 * //    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |
 * //    |                 Intermediate Node (2) Address                 |  |
 * //    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |
 * //                                   | |                                 |
 * //                                   | |                               route
 * //                                  \| |/                                |
 * //                                   \ /                                 |
 * //    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|  |
 * //    |                Intermediate Node (N) Address                  |  |
 * //    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  |
 * //    |                Query/Route Destination Address                |  |
 * //    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ -+-
 * </pre>
 */
class IARP_LinkStateUpdate : public ::inet::FieldsChunk
{
  protected:
    ::inet::L3Address sourceAddr;
    uint16_t seqNum = 0;
    uint8_t radius = 0;
    uint8_t TTL = 0;
    uint16_t reserved1 = 0;
    uint8_t reserved2 = 0;
    uint8_t linkDestCount = 0;
    IARP_LinkDestData *linkDestData = nullptr;
    size_t linkDestData_arraysize = 0;

  private:
    void copy(const IARP_LinkStateUpdate& other);

  protected:
    bool operator==(const IARP_LinkStateUpdate&) = delete;

  public:
    IARP_LinkStateUpdate();
    IARP_LinkStateUpdate(const IARP_LinkStateUpdate& other);
    virtual ~IARP_LinkStateUpdate();
    IARP_LinkStateUpdate& operator=(const IARP_LinkStateUpdate& other);
    virtual IARP_LinkStateUpdate *dup() const override {return new IARP_LinkStateUpdate(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const ::inet::L3Address& getSourceAddr() const;
    virtual ::inet::L3Address& getSourceAddrForUpdate() { handleChange();return const_cast<::inet::L3Address&>(const_cast<IARP_LinkStateUpdate*>(this)->getSourceAddr());}
    virtual void setSourceAddr(const ::inet::L3Address& sourceAddr);

    virtual uint16_t getSeqNum() const;
    virtual void setSeqNum(uint16_t seqNum);

    virtual uint8_t getRadius() const;
    virtual void setRadius(uint8_t radius);

    virtual uint8_t getTTL() const;
    virtual void setTTL(uint8_t TTL);

    virtual uint16_t getReserved1() const;
    virtual void setReserved1(uint16_t reserved1);

    virtual uint8_t getReserved2() const;
    virtual void setReserved2(uint8_t reserved2);

    virtual uint8_t getLinkDestCount() const;
    virtual void setLinkDestCount(uint8_t linkDestCount);

    virtual void setLinkDestDataArraySize(size_t size);
    virtual size_t getLinkDestDataArraySize() const;
    virtual const IARP_LinkDestData& getLinkDestData(size_t k) const;
    virtual IARP_LinkDestData& getLinkDestDataForUpdate(size_t k) { handleChange();return const_cast<IARP_LinkDestData&>(const_cast<IARP_LinkStateUpdate*>(this)->getLinkDestData(k));}
    virtual void setLinkDestData(size_t k, const IARP_LinkDestData& linkDestData);
    virtual void insertLinkDestData(size_t k, const IARP_LinkDestData& linkDestData);
    [[deprecated]] void insertLinkDestData(const IARP_LinkDestData& linkDestData) {appendLinkDestData(linkDestData);}
    virtual void appendLinkDestData(const IARP_LinkDestData& linkDestData);
    virtual void eraseLinkDestData(size_t k);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const IARP_LinkStateUpdate& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, IARP_LinkStateUpdate& obj) {obj.parsimUnpack(b);}

/**
 * Enum generated from <tt>ZrpControlPackets.msg:133</tt> by opp_msgtool.
 * <pre>
 * enum IERP_Type
 * {
 *     IERP_QUERY = 1;
 *     IERP_REPLY = 2;
 * }
 * </pre>
 */
enum IERP_Type {
    IERP_QUERY = 1,
    IERP_REPLY = 2
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const IERP_Type& e) { b->pack(static_cast<int>(e)); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, IERP_Type& e) { int n; b->unpack(n); e = static_cast<IERP_Type>(n); }

/**
 * Class generated from <tt>ZrpControlPackets.msg:139</tt> by opp_msgtool.
 * <pre>
 * class IERP_RouteData extends FieldsChunk
 * {
 *     uint8_t type;
 *     uint8_t length; //Total packet length in  multiples of 4 bytes
 *     uint8_t nodePtr;
 *     uint8_t reserved1 = 0;
 *     uint16_t queryID;
 *     uint16_t reserved2 = 0;
 *     L3Address sourceAddr;
 *     L3Address intermediateNodes[]; //The number of intermediate nodes is determined by the length field
 *     L3Address destAddr;
 * }
 * 
 * 
 * //BRP Packet
 * //
 * //	                     1                   2                   3
 * //	 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
 * //	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * //	 |                       Query Source Address                    |
 * //	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * //	 |                    Query Destination Address                  |
 * //	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * //	 |           Query ID            |Query Extension|    RESERVED   |
 * //	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * //	 |                    Prev Bordercast Address                    |   
 * //	 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 
 * //	 |                                                               |
 * //   |            E N C A P S U L A T E D     P A C K E T            |
 * // 	 |                                                               |
 * //   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 * </pre>
 */
class IERP_RouteData : public ::inet::FieldsChunk
{
  protected:
    uint8_t type = 0;
    uint8_t length = 0;
    uint8_t nodePtr = 0;
    uint8_t reserved1 = 0;
    uint16_t queryID = 0;
    uint16_t reserved2 = 0;
    ::inet::L3Address sourceAddr;
    ::inet::L3Address *intermediateNodes = nullptr;
    size_t intermediateNodes_arraysize = 0;
    ::inet::L3Address destAddr;

  private:
    void copy(const IERP_RouteData& other);

  protected:
    bool operator==(const IERP_RouteData&) = delete;

  public:
    IERP_RouteData();
    IERP_RouteData(const IERP_RouteData& other);
    virtual ~IERP_RouteData();
    IERP_RouteData& operator=(const IERP_RouteData& other);
    virtual IERP_RouteData *dup() const override {return new IERP_RouteData(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual uint8_t getType() const;
    virtual void setType(uint8_t type);

    virtual uint8_t getLength() const;
    virtual void setLength(uint8_t length);

    virtual uint8_t getNodePtr() const;
    virtual void setNodePtr(uint8_t nodePtr);

    virtual uint8_t getReserved1() const;
    virtual void setReserved1(uint8_t reserved1);

    virtual uint16_t getQueryID() const;
    virtual void setQueryID(uint16_t queryID);

    virtual uint16_t getReserved2() const;
    virtual void setReserved2(uint16_t reserved2);

    virtual const ::inet::L3Address& getSourceAddr() const;
    virtual ::inet::L3Address& getSourceAddrForUpdate() { handleChange();return const_cast<::inet::L3Address&>(const_cast<IERP_RouteData*>(this)->getSourceAddr());}
    virtual void setSourceAddr(const ::inet::L3Address& sourceAddr);

    virtual void setIntermediateNodesArraySize(size_t size);
    virtual size_t getIntermediateNodesArraySize() const;
    virtual const ::inet::L3Address& getIntermediateNodes(size_t k) const;
    virtual ::inet::L3Address& getIntermediateNodesForUpdate(size_t k) { handleChange();return const_cast<::inet::L3Address&>(const_cast<IERP_RouteData*>(this)->getIntermediateNodes(k));}
    virtual void setIntermediateNodes(size_t k, const ::inet::L3Address& intermediateNodes);
    virtual void insertIntermediateNodes(size_t k, const ::inet::L3Address& intermediateNodes);
    [[deprecated]] void insertIntermediateNodes(const ::inet::L3Address& intermediateNodes) {appendIntermediateNodes(intermediateNodes);}
    virtual void appendIntermediateNodes(const ::inet::L3Address& intermediateNodes);
    virtual void eraseIntermediateNodes(size_t k);

    virtual const ::inet::L3Address& getDestAddr() const;
    virtual ::inet::L3Address& getDestAddrForUpdate() { handleChange();return const_cast<::inet::L3Address&>(const_cast<IERP_RouteData*>(this)->getDestAddr());}
    virtual void setDestAddr(const ::inet::L3Address& destAddr);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const IERP_RouteData& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, IERP_RouteData& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>ZrpControlPackets.msg:171</tt> by opp_msgtool.
 * <pre>
 * class BRP_Data extends FieldsChunk
 * {
 *     L3Address sourceAddr;
 *     L3Address destAddr;
 *     uint16_t queryID;
 *     uint8_t queryExtension;
 *     uint8_t reserved = 0;
 *     L3Address prevBordercastAddr;
 *     IERP_RouteData encapsulatedPacket; //The packet being sent to the destination
 * }
 * </pre>
 */
class BRP_Data : public ::inet::FieldsChunk
{
  protected:
    ::inet::L3Address sourceAddr;
    ::inet::L3Address destAddr;
    uint16_t queryID = 0;
    uint8_t queryExtension = 0;
    uint8_t reserved = 0;
    ::inet::L3Address prevBordercastAddr;
    IERP_RouteData encapsulatedPacket;

  private:
    void copy(const BRP_Data& other);

  protected:
    bool operator==(const BRP_Data&) = delete;

  public:
    BRP_Data();
    BRP_Data(const BRP_Data& other);
    virtual ~BRP_Data();
    BRP_Data& operator=(const BRP_Data& other);
    virtual BRP_Data *dup() const override {return new BRP_Data(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const ::inet::L3Address& getSourceAddr() const;
    virtual ::inet::L3Address& getSourceAddrForUpdate() { handleChange();return const_cast<::inet::L3Address&>(const_cast<BRP_Data*>(this)->getSourceAddr());}
    virtual void setSourceAddr(const ::inet::L3Address& sourceAddr);

    virtual const ::inet::L3Address& getDestAddr() const;
    virtual ::inet::L3Address& getDestAddrForUpdate() { handleChange();return const_cast<::inet::L3Address&>(const_cast<BRP_Data*>(this)->getDestAddr());}
    virtual void setDestAddr(const ::inet::L3Address& destAddr);

    virtual uint16_t getQueryID() const;
    virtual void setQueryID(uint16_t queryID);

    virtual uint8_t getQueryExtension() const;
    virtual void setQueryExtension(uint8_t queryExtension);

    virtual uint8_t getReserved() const;
    virtual void setReserved(uint8_t reserved);

    virtual const ::inet::L3Address& getPrevBordercastAddr() const;
    virtual ::inet::L3Address& getPrevBordercastAddrForUpdate() { handleChange();return const_cast<::inet::L3Address&>(const_cast<BRP_Data*>(this)->getPrevBordercastAddr());}
    virtual void setPrevBordercastAddr(const ::inet::L3Address& prevBordercastAddr);

    virtual const IERP_RouteData& getEncapsulatedPacket() const;
    virtual IERP_RouteData& getEncapsulatedPacketForUpdate() { handleChange();return const_cast<IERP_RouteData&>(const_cast<BRP_Data*>(this)->getEncapsulatedPacket());}
    virtual void setEncapsulatedPacket(const IERP_RouteData& encapsulatedPacket);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BRP_Data& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BRP_Data& obj) {obj.parsimUnpack(b);}


}  // namespace zrp
}  // namespace inet


namespace omnetpp {

template<> inline inet::zrp::NDP_Hello *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::zrp::NDP_Hello*>(ptr.get<cObject>()); }
inline any_ptr toAnyPtr(const inet::zrp::IARP_MetricData *p) {return any_ptr(p);}
template<> inline inet::zrp::IARP_MetricData *fromAnyPtr(any_ptr ptr) { return ptr.get<inet::zrp::IARP_MetricData>(); }
inline any_ptr toAnyPtr(const inet::zrp::IARP_LinkDestData *p) {return any_ptr(p);}
template<> inline inet::zrp::IARP_LinkDestData *fromAnyPtr(any_ptr ptr) { return ptr.get<inet::zrp::IARP_LinkDestData>(); }
template<> inline inet::zrp::IARP_LinkStateUpdate *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::zrp::IARP_LinkStateUpdate*>(ptr.get<cObject>()); }
template<> inline inet::zrp::IERP_RouteData *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::zrp::IERP_RouteData*>(ptr.get<cObject>()); }
template<> inline inet::zrp::BRP_Data *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::zrp::BRP_Data*>(ptr.get<cObject>()); }

}  // namespace omnetpp

#endif // ifndef __INET__ZRP_ZRPCONTROLPACKETS_M_H

